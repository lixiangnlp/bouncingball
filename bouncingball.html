<html>
  <head>
    <script type="application/javascript" src="base.js"></script>
    <script id="v0" type="x-shader/x-vertex">
      uniform float time;
      uniform mat4 projection, view;
      attribute vec3 position, barycentric;
      varying vec3 fragment_barycentric, fragment_position;
      varying vec4 fragment_world_position;

      const float kEpsilon = 1e-0;

      vec3 Constant(float c) {
        return vec3(0.0, 0.0, c);
      }

      vec3 Multiply(vec3 u, vec3 v) {
        return vec3(
          u.x * v.z + u.z * v.x,
          u.y * v.z + u.z * v.y,
          u.z * v.z
        );
      }

      vec3 Divide(vec3 u, vec3 v) {
        return vec3(
          (u.x * v.z - u.z * v.x) / v.z / v.z,
          (u.y * v.z - u.z * v.y) / v.z / v.z,
          u.z / v.z
        );
      }

      vec3 Sin(vec3 u) {
        return vec3(
          u.x * cos(u.z),
          u.y * cos(u.z),
          sin(u.z)
        );
      }

      vec3 X(float x) {
        return vec3(1.0, 0.0, x);
      }

      vec3 Y(float y) {
        return vec3(0.0, 1.0, y);
      }

      vec3 Sinc(vec3 u) {
        return Divide(
          Sin(u - Constant(time) + Constant(kEpsilon)),
          u + Constant(kEpsilon)
        );
      }

      vec3 Square(vec3 u) {
        return vec3(
          u.x * 2.0 * u.z,
          u.y * 2.0 * u.z,
          u.z * u.z
        );
      }

      vec3 SquareRoot(vec3 u) {
        float s = sqrt(u.z);
        return vec3(u.x / s / 2.0, u.y / s / 2.0, s);
      }

      vec3 f(vec2 xz) {
        vec3 x = X(xz.x);
        vec3 z = Y(xz.y);
        vec3 t = Constant(time);
        // return Sin(x - t) + Divide(Square(z), Constant(1000.0));
        return Multiply(t, Sinc(Divide(Divide(Square(x) + Square(z), t), t))) +
            Divide(Square(
              Multiply(Constant(10.0), t) - SquareRoot(Square(x) + Square(z))
            ), Constant(1000.0));
      }

      void main() {
        fragment_barycentric = barycentric;
        float f_at_0 = f(vec2(0.0)).z;
        float f_at_xz = f(position.xz).z;
        fragment_position = vec3(position.x, position.y + f_at_xz - f_at_0, position.z);
        gl_Position = projection * view * vec4(position.x, position.y + f_at_xz - f_at_0, position.z /*- 10.0 * time*/, 1.0);
        fragment_world_position = view * vec4(position.x, position.y + f_at_xz - f_at_0, position.z, 1.0);
      }
    </script>
    <script id="f0" type="x-shader/x-fragment">
      precision mediump float;
      uniform bool wireframe;
      uniform highp float time;
      varying vec3 fragment_barycentric, fragment_normal, fragment_position;
      varying vec4 fragment_world_position;

      const float kEpsilon = 1e-0;

      vec3 Constant(float c) {
        return vec3(0.0, 0.0, c);
      }

      vec3 Multiply(vec3 u, vec3 v) {
        return vec3(
          u.x * v.z + v.x * u.z,
          u.y * v.z + v.y * u.z,
          u.z * v.z
        );
      }

      vec3 Divide(vec3 u, vec3 v) {
        return vec3(
          (u.x * v.z - u.z * v.x) / v.z / v.z,
          (u.y * v.z - u.z * v.y) / v.z / v.z,
          u.z / v.z
        );
      }

      vec3 Sin(vec3 u) {
        return vec3(
          u.x * cos(u.z),
          u.y * cos(u.z),
          sin(u.z)
        );
      }

      vec3 X(float x) {
        return vec3(1.0, 0.0, x);
      }

      vec3 Y(float y) {
        return vec3(0.0, 1.0, y);
      }

      vec3 Sinc(vec3 u) {
        return Divide(
          Sin(u - Constant(time) + Constant(kEpsilon)),
          u + Constant(kEpsilon)
        );
      }

      vec3 Square(vec3 u) {
        return vec3(
          u.x * 2.0 * u.z,
          u.y * 2.0 * u.z,
          u.z * u.z
        );
      }

      vec3 SquareRoot(vec3 u) {
        float s = sqrt(u.z);
        return vec3(u.x / s / 2.0, u.y / s / 2.0, s);
      }

      vec3 f(vec2 xz) {
        vec3 x = X(xz.x);
        vec3 z = Y(xz.y);
        vec3 t = Constant(time);
        // return Sin(x - t) + Divide(Square(z), Constant(1000.0));
        return Multiply(t, Sinc(Divide(Divide(Square(x) + Square(z), t), t))) +
            Divide(Square(
              Multiply(Constant(10.0), t) - SquareRoot(Square(x) + Square(z))
            ), Constant(1000.0));
      }

      vec3 normal_f(vec2 xz) {
        vec3 f = f(xz);
        return normalize(vec3(-f.x, 1.0, -f.y));
      }

      const float c = 0.01;
      const float b = 0.01;

      vec3 applyFog( in vec3  rgb,      // original color of the pixel
                     in float distance, // camera to point distance
                     in vec3  rayOri,   // camera position
                     in vec3  rayDir )  // camera to point vector
      {
          float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;
          // float fogAmount = exp( -distance*b );
          vec3  fogColor  = vec3(0.5,0.6,0.7);
          return mix( rgb, fogColor, fogAmount );
      }

      void main() {
        vec3 light_direction = normalize(vec3(1000.0 * cos(0.0), 1000.0, 1000.0 * sin(0.0)) - fragment_world_position.xyz);
        float product = dot(normal_f(fragment_position.xz), light_direction);
        product *= 0.5;
        product += 0.5;
        product *= product;
        float light = product;
        if (gl_FrontFacing) {
          if (wireframe && any(lessThan(fragment_barycentric.xz, vec2(0.05)))) {
            gl_FragColor = vec4(vec3(0.0), 1.0);
          } else {
            gl_FragColor = vec4(vec3(light) + 0.0, 1.0);
          }
        } else {
          gl_FragColor = vec4(vec3(light) + 0.0, 0.5);
        }
      }
    </script>
    <style type="text/css">
      body {
        margin: 0px;
      }
      #c {
        width: 100%;
        height: 100%;
      }
      #container {
        float: left;
      }
    </style>
  </head>
  <body onload="bouncingball.load();">
    <div id="container">
      <canvas id='c0'></canvas>
    </div>
  </body>
</html>
